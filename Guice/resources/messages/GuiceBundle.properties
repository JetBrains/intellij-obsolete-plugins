conflicting.annotations.display.name=Conflicting Guice annotations
conflicting.annotations.problem.descriptor=Annotation #ref conflicts with other declared annotations
multiple.binding.annotations.display.name=Multiple binding annotations on variable
multiple.binding.annotations.problem.descriptor=Variable #ref has multiple binding annotations
binding.annotation.without.inject.display.name=Binding annotations without @Inject
binding.annotation.without.inject.problem.descriptor=Binding annotation #ref without @Inject declared
interception.annotation.without.runtime.retention.display.name=Interception annotation without runtime retention
interception.annotation.without.runtime.retention.problem.descriptor=Annotation #ref does not have Runtime retention
invalid.request.parameters.display.name=Incorrect type for @RequestParameters parameters
invalid.request.parameters.problem.descriptor=Variables or parameters labeled #ref must have type Map<String, String[]>
invalid.implemented.by.display.name=Invalid @ImplementedBy annotation
invalid.implemented.by.problem.descriptor=Class #ref doesn't implement annotated class
singleton.injects.scoped.display.name=@Singleton component injects scoped component
singleton.injects.scoped.problem.descriptor=@Inject of scoped class #ref from @Singleton class
group.guice.inspections.name=Guice
session.scoped.injects.request.scoped.display.name=@SessionScoped component injects @RequestScoped component
session.scoped.injects.request.scoped.problem.descriptor=@Inject of @RequestScoped class #ref from @SessionScoped class
invalid.provided.by.display.name=Invalid @ProvidedBy annotation
invalid.provided.by.problem.descriptor=Class #ref doesn't provide annotated class
uninstantiable.implemented.by.class.display.name=Uninstantiable @ImplementedBy class
uninstantiable.implemented.by.class.problem.descriptor=Class #ref is uninstantiable, and thus can not be @ImplementedBy
uninstantiable.provided.by.class.display.name=Uninstantiable @ProvidedBy class
uninstantiable.provided.by.class.problem.descriptor=Class #ref is uninstantiable, and thus can not be @ProvidedBy
uninstantiable.binding.display.name=Uninstantiable binding
uninstantiable.binding.problem.descriptor=Class #ref is uninstantiable, and thus can not be bound
redundant.to.binding.display.name=Redundant binding
redundant.to.binding.problem.descriptor=Binding to class #ref is redundant
redundant.to.provider.binding.display.name=Redundant provider binding
redundant.to.provider.binding.problem.descriptor=Binding to class #ref is redundant
redundant.scope.binding.display.name=Redundant scope binding
redundant.scope.binding.problem.descriptor=Binding to scope #ref is redundant
pointless.binding.display.name=Pointless binding
pointless.binding.problem.descriptor=Binding is unnecessary, and can be removed
unnecessary.static.injection.display.name=Unnecessary static injection
unnecessary.static.injection.problem.descriptor=Class #ref has no static @Inject members
multiple.injected.constructors.for.class.display.name=Multiple @Inject constructors for class
multiple.injected.constructors.for.class.problem.descriptor=Class #ref has multiple @Inject constructors
move.binding.scope.to.class.text=Move binding scope to class
move.binding.scope.to.class.family.name=Move Binding Scope To Class
move.binding.to.class.text=Move binding class to class
move.binding.to.class.family.name=Move Binding To Class
move.provider.binding.to.class.text=Move provider binding to class
move.provider.binding.to.class.family.name=Move Provider Binding To Class
guice.intentions=Guice
new.guice.module.error=Cannot create Guice module
new.guice.module.action.name=Create Guice module
new.guice.module.name=Creating Guice module: {0}.{1}
new.guice.scope.annotation.error=Cannot create Guice scope annotation
new.guice.scope.annotation.action.name=Create Guice scope annotation
new.guice.binding.annotation.error=Cannot create Guice binding annotation
new.guice.binding.annotation.action.name=Create Guice binding annotation
new.guice.binding.annotation.name=Creating Guice binding annotation: {0}.{1}
new.guice.method.interceptor.error=Cannot create Guice method interceptor
new.guice.method.interceptor.action.name=Create Guice method interceptor
new.guice.method.interceptor.name=Creating Guice method interceptor: {0}.{1}
new.guice.provider.error=Cannot create Guice provider
new.guice.provider.action.name=Create Guice provider
new.guice.provider.name=Creating Guice provider: {0}.{1}
toggle.injection.required.family.name=Toggle Injection
make.injection.optional=Make injection optional
make.injection.mandatory=Make injection mandatory
toggle.required=Toggle 'optional'
group.GuiceActionGroup.text=Google Guice
group.GuiceActionGroup.description=Google Guice components
delete.binding=Delete binding
select.provided.class=Select class to provide
GuiceClassAnnotator.popup.title=Select Expression to Navigate to
GuiceClassAnnotator.popup.tooltip.text=Navigate to Guice bind expression
gutter.choose.injected.point=Choose Injection Point
gutter.navigate.to.injection.point=Navigate to injection points
provider.class.name=Provider Class Name:
class.provided=Class Provided:
new.guice.provider=New Guice Provider
ImplicitSubclassInspection.display.forMethod.annotated=@Transactional methods must not be private